# libft
libft library		
1	int ft_atoi(const char *str);	Принимает на вход указатель на строку. В строке могут быть не только цифры, но и буквы, знаки препинания и прочее. Так же знак плюса и минуса.	Вернуть числовое значение типа int	"1. В начале строки пропускает символы isspace до момента появления знака (знак плюса может присутствовать, но игнорируется при выводе). Если после знака минуса (или плюса) находиться что-то кроме цифры (в том числе еще один знак минуса или плюса), то возвращает 0. Далее в строке идет считывание символов до тех пока либо строка не закончиться, либо встретиься что-то кроме цифры. После того, как число доходит до предельных значений int (-2 млрд --- 2 млрд) происходит движение числа по кругу int. Например если приходит строка с числом 2147483648, то на выходе будет число - 2147483648. Так происходит до тех пор пока число знаков в строке не станет равной 19. При этом условии: если число положительное, то возвращается -1, если число полодительное, то 0."
2	void ft_bzero(void *s, size_t n)	Принимает номер символа 	Ничего не возвращает	Записывает n раз 0 в строку по указателю s. Если n=0, то функция ничего не делает. Если n=0, то функция ничего не делает. Можно воспользоваться функцией ft_memset
3	void *ft_calloc(size_t count, size_t size)	Выделяет память для count*size байт и заполняет их нулями.	Возвращает указатель на выделенную память	Можно воспользоваться функцию ft_bzero. Возвращаемый указатель имеет тип void.
4	int ft_isalnum(int c);	Принимает номер символа 	Возвращает 0, если символ не является числом или буквой. И возвращает с , если он является числом или буквой 	Проверяетявляется ли символ числом или буквой.
5	int ft_isalpha(int c);	Принимает номер символа 	Возвращает 0 если символ не является буквой. И возвращает с если это буква	Буква может быть как большая так и маленькая. Проверяется по  ASCII
6	int ft_isascii(int c);	Принимает номер символа 	Возвращает 0 если символ не входит в ASCII. И возвращает с если входит	с >= 0 && c <= 127
7	int ft_isdigit(int c);	Принимает номер символа 	Возвращает 0 если символ не является цифрой. И возвраащет сб если число	
8	int ft_isprint(int c);	Принимает номер символа 	Возвращает 0 если символ НЕпечатаемый. И возвращает 1, если символ печатаемый	с > 31 && c < 127. 127 символ (del) также непечатаемый
9	char *ft_itoa(int a);	Принимает число типа int	Переводит число в строку и возвращает указатель на эту строку	Нужно обязательно учитывать знак числа
10	void *ft_memccpy(void *dst, const void *src, int c, size_t n);	Принимает указатель на строку dst в нее копируем n байт из строки src до тех пор пока не встретиться символ c в строке src	В случае когда все скопировалось возвращает NULL. В случае когда в строке src встретился символ 'c' они копируется в dst копирование останавливается и возвращается указатель на следующий символ в строке dst	Символ 'c' обязательно нужно склпировать в dst. Если строки перекрываются то поведение не определено
11	void *ft_memcpy(void *dst, void *src, size_t n);	Принимает указатель на строку dst,в которую нужно скопировать n байт из строки src	Возвращает указатель dst	Нужно проверить строки dst и src на существование. Беспокоиться о том, что строка src может быть меньше чем n не стоит. Если строки перекрываются то поведение не определено
12	void *ft_memchr(const void *s, int c, size_t n);	Принимает указатель на массив s и n - число байтов, в пределах которых нужно проверить наличие символа 'c'.	Возвращает NULL, если символ 'c' в пределах n байт не был найден. И возвращает указатель на символ 'c' в строке s	Символ 'c'  приходит как intи нужно приводить к unsigned char
13	int ft_memcmp(const void *s1, const void *s2, size_t n);	Принимает указатели на массив s1 и s2, в которых сравнивает первые n байт.	Возвращает 0, если байты одинаковые, отрицательное число, если байт в s2 больше и положительное число, если s1 больше	(int)*a - *b;
14	void *ft_memmove(void *dst, const void *src, size_t len);	Копирует len байт из строки src в строку dst	Возвращает указатель на dst.	В случае когда строки пересекаются, необходимо сравнить адреса dst  и src и если dst > src то копировать с конца (dst[--len] = src[len]). Во всех остальных случаях можно использовать ft_memcpy
15	void *ft_memset(void *b, int c, size_t len);	Принимает указатель на массив b, в который записывает len байтов с	Возвращает указатель на b	Проверку на выход за пределы строки делать не надо
16	void ft_putchar_fd(char c, int fd);	Принимает файловый дескриптор, используя который нужно записать в файл символ с	Ничего не возвращает	Использует функцию write, где первым параметром использвать файловый дескриптор
17	void ft_putstr_fd(char *c, int fd);	Принимает файловый дескриптор fd по которому записать в файл строку, на которую указывает указатель s	Ничего не возвращает	Проверить строку на существование. Использовать функцию write]
18	void ft_putendl_fd(char *s, int fd);	Принимает файловый дескриптор fd, по которому записать строку s и после добавить символ перевода каретки \n	Ничего не возвращает	Проверить строку на существование. Использовать функцию write  И использовать функцию ft_putstr_fd
19	void ft_putnbr_fd(int n, int fd);	Принимает файловый дескриптор, по которому записать в файл число n	Ничего не возвращает	Использовать рекурсию. И привести n к unsigned int
20	char **ft_split(char const *s, char c);	Принимает указатель на строку s, кторую нужно разделить по символу c и записать в массив строк 	Вернуть массив строк	Использовать кастомные функции для подсчета слов и подсчета символов в слове. Учесть, что разделитель может быть перед строкой и в конце строки. Учесть , что в самой строке разделители могут идти подряд друг за другом
21	char *ft_strtrim(char const *str, char const *set);	Удалить символы из строки set в начале и конце строки s	Вернуть указатель на строку,  которую выделили mallocoм память и скопировали полученную строку 	Использовать ft_strchr и ft_substr
22	char *ft_substr(char const *s, unsigned int start, size_t len);	Принимает указатель на строку s, из которой нужно скопировать len символов начиная с индекса start в новую строку, которую выделили mallocом	Вернуть указатель на новую строку 	"Учесть, что строки s может не быть. Защитить malloc. Если start >= длине s, то вернуть укзатель на пустую строку, выделенную mallocом.
ВАЖНОЕ ЗАМЕЧАНИЕ!
Один из пиров отметил, что нужно сравнивать длину строки s и размер len и mallocom выделяить память для наименьшей величины. Пример: длина строки s==10, а len приходит 500. Если проигнорировать аспект сравнения, то будет выделено лишних 490 байт. Так же malloc может не выдать память для строки из 10 байт, т.к. не будет 500 хотя реально нужно 10. В моем коде такой проверки нет, т.к. ориентируюсь на Мулинет. "
23	char *ft_strdup(const char *s1);	Принимает строку s1, которую нужно скопировать в новую строку, выделенную mallocом	Вернуть указатель на новую строку 	Защитить malloc
24	char *ft_tolower(int c);	Переводит и возвращает символ 'c', если это большая буква в маленькую		
25	char ft_toupper(int c);	Переводит и возвращает символ 'c', если это маленька буква в большую		
26	size_t ft_strlcat(char *dst, const char *src, size_t dstsize);	 Принимает указатель на буффер dst с размером dstsize,в который нужно сконкотинатить строку src и ОБЯЗАТЕЛЬНО закончить полученную строку NUL-терминатором 	Возвращает длину строки, которую может создать. Если размер dst >= dstzize,то вернуть dstsize+длину src.	
27	size_t ft_strlen(const char *s);	Принмает указатель на строку s	Возвращает длину s	
28	char *ft_strchr(const char *s, int c);	Принимает указатель на строкуб в которой нужно найти первое вхождение символа 'c'	Вернуть указатель на на символ 'c' в строке s. Если его в строке нет вернуть NULL. Если в качестве искомого символк 'c' пришел '\0', то вернуть указатель на '\0' строки s	Сделать проверку на то, что символ 'c' это '\0'.
29	char *ft_strrchr(const char *s, int c);	Принимает указатель на строкуб в которой нужно найти последнее вхождение символа 'c'	Вернуть указатель на на символ 'c' в строке s. Если его в строке нет вернуть NULL. Если в качестве искомого символк 'c' пришел '\0', то вернуть указатель на '\0' строки s	Сделать проверку на то, что символ 'c' это '\0'.
30	char *ft_strjoin(char const *s1, char const *s2);	Принимает указатели на строки s1 и s2, которые нужно объединить и скопировать в строку, которую выделить mallocом. В конце полученной строки обязательно '\0'	Вернуть указатель на полученную строку	Прповерить строки s1 и s2 на существованиею
31	size_t ft_strlcpy(char *dst, const char *src, size_t dstsize);	Принимает указатели на строку dst, в которую нужно скаопировать dstsize байт из строки src	Возвращает длину строку, которую могбы скопировать (длина src)	"Проверить указатели на существование.
Если dstsize == 0, то вернет длину src.
В конце скопированной строки обязательн поставить '\0'"
32	char *ft_strmapi(char const *s, char (*f)(unsigned int, char));	Принимает указатель s на строку. Выделяет mallocom память для новой строки, в которую нужно сокпировать символы из строки s, к каждому символу которой применитиь функцию f.	Возвращает указатель на новую строку	Проверить строку и функцию на существование
33	int ft_strncmp(const char *s1, const char *s2, size_t n);	Принимает указатели на строки s1 и s2, в которых сравнивает первые n байт в лексикографическом порядке	Возвращает 0, если чтроки равны. Положительное значение, если строка s1 > s2 и отрицательное значение, если чтрока s1 < s2	"Строки. проверяются до тех пор пока не закончатся обе или не закончатся количество сравниваемых байтов.
Если одна из строк закончилась раньше чем n, то сравнение продолжиться еще на один байт, где будет сравниваться конц закончившейся строки и следующий символ другой строки"
34	char *ft_strnstr(const char *str, const char *to_fibd, size_t len);	Принимает указатель на строку str, в которой на протяжении len байт ищет сроку to_find	"Если строки to_find не существует, то вернуть указатель на str.
Если строка не найдена возвращает NULL. 
Во всех остальных случаях возвращает указатель на начало строки to_find в строке str "	NUL-терминатор строки to_find не учитывается
35	ft_lstnew(void *data)'	Принимает на вход указатель на данные, которе нужно использовать при создании нового узла для связного списка	Возвращает указатель на созданный узел	Выделить память mallocom для структуру t_list
36	ft_lstadd_front(t_list **lst, t_list *new);	Принимает указатель на узел new, который нужно поставить на первое место связного списка, на который указывает lst	Ничего не возвращает	"Если new не существует, то функцию прекращает свое действие.
Если *lst никуда не указывает, то *lst = new и функция заканчивается"
37	ft_lstadd_back(t_list **lst, t_list *new);	Принимает указатель на начало связного списка lst, в конец которого нужно поместить узел new	Ничего не возвращает	"Если new не существует, то функция заканчивает работу.
Если *lst никуда не указывает, то *lst = new,
Использовать функцию ft_lstlast"
38	ft_lstlast(t_list *lst);	Принимает указатель на связный список lst	"Возвращает последний узел связного списка.
Если lst не существует, вернуть NULL"	В цикле условие while (tmp->next)
39	ft_lstsize(t_list *lst);	Принимает указатель на начало связного списка, чей размер нужно высчитать	"Вернуть размер связного списка lst.
Если lst не существует, то вернуть 0"	В цикле условие while (tmp)
40	ft_lstdelone(t_list *lst, void (*del)(void *));	Принимает указатель на узел и указаетль на функцию, которая стирает контент узла.	Ничего не возвращает	"Если lst не сущестувет функция заканчивает работу.
Нужно освободить указатель методом free"
41	ft_lstclear(t_list **lst, void (*del)(void *));	Принимает указатель на начало связного списка lst, в котором нужно удалить все узлы используя функцию del для контента и функцию free для указателей	Ничего не возвращает	"Если не существует lst или del, то функция заканчивает работу.
Указатель на начало списка установить на NULL"
42	ft_lstiter(t_list *lst, void (*f)(void *));	Принимает указатель на связный список lst, в котором к контенту каждого узла применить функцию f	Ничего не возвращает	Если функции f не существует, функция заканчивает работу
43	ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));	Принимает указатель на связный список lst, чью копию нужно сделать (применив malloc), применив для контента каждого элемента функцию f. Если не получится выделить mallocom память хотя бы для одного элемента, то стереть весь новый связный список с использованием функции del для контента каждого элемента	Возвращает указатель на новый связный список	Ппроверить lst и f на существование
